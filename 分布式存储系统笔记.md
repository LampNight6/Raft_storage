# 分布式存储系统笔记



## CAP理论

一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

分区容错性，指节点之间出现通信故障（包括网络故障或机器故障），那么这两个节点之间出现分区

一致性，指节点对于写请求发生一致性变化，当发生分区错误时，为保证一致性不返回任何数据

可用性，指节点在收到请求后必须在规定时间内处理并返回结果

基于对分布式系统的基本要求，分区容错性是必须被满足的（即不能因为一个节点的错误导致整体系统的瘫痪）。所以分布式系统可以根据偏向分为CP系统和AP系统。

当一套系统在发生分区故障后，客户端的任何请求都被卡死或者超时，但是，系统的每个节点总是会返回一致的数据，则这套系统就是 CP 系统，经典的比如 Zookeeper。

如果一套系统发生分区故障后，客户端依然可以访问系统，但是获取的数据有的是新的数据，有的还是老数据，那么这套系统就是 AP 系统，经典的比如 Eureka。

当业务强调一致性需求时，比如支付系统、预定系统等则偏向使用CP系统。当业务强调可用性需求时，比如社交网络、内容分发、日志系统等则偏向使用AP系统。

PS:

C和A的取向不是二元的，而是有所取舍的。

当没有出现分区问题时，系统应该保持完美的一致性和可用性。

C和A的选择不一定是整体的，可能是部分的。比如用户账号数据中，密码、余额此类数据需要一致性，昵称、偏好这类数据不一定考虑强一致性，可以选择可用性。



## PACELC理论

CAP理论并不能很好的指导现实的系统架构。比如Availability (可用性)，如果接口长时间才返回结果，固然可用，但是业务上不能接受。大部分情况下，系统分区都是平稳运行的，系统设计要权衡延迟与数据一致性的问题。为了保证数据一致性，读写的延迟必然升高。

在分区错误的情况下，在C和A中取舍，缩写为 PAC。分区正确的情况下，取 Latency（延迟）与 Consistency（一致性），缩写为LC。PACELC 中的 E 代表 Else，连起来就是PACELC。

很多存储软件实现了 PACELC 的策略，用户根据不同业务场景使用不同的配置。以MySQL主从复制为例，提供了三种模式：

异步模式：主库执行完客户端提交的事务，立即将结果返给客户端，不关心从库是否已经接收并处理。由于数据同步的延时，客户端在从库上可能读不到最新数据。这种模式对MySQL是性能最佳的，但是用户需要权衡，业务能否忍受这种延时。
全同步复制：主库执行完客户端提交的事务，所有的从库都执行了该事务才返回结果。这样保证强一致性，但是响应时间变长了。
半同步复制：主库在执行完客户端提交的事务后，等待至少一个从库接收到并写到 relay log 中，才返回给客户端。这样做延迟小了很多，相比于异步复制，数据更加不容易丢失。



## 一致性模型

### 强一致性

**顺序一致性：**

- 条件 I：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。
- 条件 II：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。

**线性一致性：**

- 条件 III：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。

也就是说顺序一致性只要求在总的操作顺序中体现进程（处理器）内的操作顺序即可，而线性一致性要求所有操作顺序必须完全与真实顺序一致。

### 弱一致性

弱一致性是指系统在数据成功写入之后，不承诺立即可以读到最新写入的值，也不会具体承诺多久读到，但是会尽可能保证在某个时间级别之后，可以让数据达到一致性状态。

可以根据能够恢复一致的时间将弱一致性进一步分类，如果是有限时间那就是最终一致性，如果是无限时间那实际上相当于没有一致性。

#### 最终一致性的种类

在实际工程实践中，最终一致性常被分为 5 种：

**因果一致性（Causal consistency）**
如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。与此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。

**读己之所写（Read your writes）**
节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。

**会话一致性（Session consistency）**
系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。

**单调读一致性（Monotonic read consistency）**
如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。

**单调写一致性（Monotonic write consistency）**
一个系统要能够保证来自同一个节点的写操作被顺序的执行。



## 一致性与共识的区别

一致性往往指分布式系统中多个副本对外呈现的数据的状态。如前面提到的顺序一致性、线性一致性，描述了多个节点对数据状态的维护能力。

共识性则描述了分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。

因此，一致性描述的是结果状态，共识则是一种手段。达成某种共识并不意味着就保障了一致性（这里的一致性指强一致性）。只能说共识机制，能够实现某种程度上的一致性。

实践中，要保障系统满足不同程度的一致性，核心过程往往需要通过共识算法来达成。



## 共识算法

### Zab（Zookeeper）

Zookeeper 中针对同一个 follower A 提交的写请求 request1、request2，某些 follower 虽然可能不能在请求提交成功后立即看到（也就是强一致性），但经过自身与 leader 之间的同步后，这些 follower 在看到这两个请求时，一定是先看到 request1，然后再看到 request2，两个请求之间不会乱序，即顺序一致性。

从整体（read 操作 + write 操作）上来说是 顺序一致性，写操作实现了线性一致性。

### Raft（etcd）